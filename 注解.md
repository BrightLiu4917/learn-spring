### 使用注解案例
1 新增枚举类 PermissionEnum.java
```java
package com.liuweiliang.demo1.enums;

import lombok.Getter;

/**
 * 权限枚举：限定系统所有权限类型，删除账户仅支持SUPER_ADMIN
 */
@Getter // Lombok生成getter，方便AOP/业务层获取属性
public enum PermissionEnum {
    /**
     * 超级管理员：拥有所有权限（包含删除账户）
     * 普通管理员：仅拥有查询/编辑等基础权限，无删除权限
     */
    SUPER_ADMIN(1, "超级管理员", "拥有账户删除、配置等所有系统权限"),
    ADMIN(0, "普通管理员", "仅拥有账户查询、编辑等基础权限，无删除权限");

    // 权限码：存入JWT，轻量易传输
    private final Integer permCode;
    // 权限名称：前端展示/日志打印
    private final String permName;
    // 权限描述：详细说明，便于维护
    private final String permDesc;

    // 枚举构造器必须为private，外部无法new
    PermissionEnum(Integer permCode, String permName, String permDesc) {
        this.permCode = permCode;
        this.permName = permName;
        this.permDesc = permDesc;
    }

    /**
     * 辅助方法：根据权限码获取枚举（核心：JWT解析出权限码后转成枚举，方便对比）
     * @param permCode 权限码（0=超级管理员，1=普通管理员）
     * @return 对应的权限枚举，默认返回普通管理员
     */
    public static PermissionEnum getByCode(Integer permCode) {
        for (PermissionEnum perm : PermissionEnum.values()) {
            if (perm.getPermCode().equals(permCode)) {
                return perm;
            }
        }
        return ADMIN;
    }
}
```


2 新增注解 RequirePermission.java 
```java
package com.liuweiliang.demo1.annotation;

import com.liuweiliang.demo1.enums.PermissionEnum;

import java.lang.annotation.*;

/**
 * 权限控制注解：标记方法需要的权限类型，仅拥有对应权限的用户可调用
 * 作用于：方法
 * 保留策略：运行时（AOP需要在运行时解析注解）
 */
@Target({ElementType.METHOD}) // 仅允许贴在方法上（接口/Service方法）
@Retention(RetentionPolicy.RUNTIME) // 运行时保留，AOP才能解析 只有运行时保留的注解才能被AOP解析
@Documented // 生成API文档时显示该注解，便于团队协作
public @interface RequirePermission {
    /**
     * 注解属性：方法需要的权限类型
     * 默认值：普通管理员（ADMIN），删除账户接口手动指定为超级管理员（SUPER_ADMIN）
     */
    PermissionEnum value() default PermissionEnum.ADMIN;
}
```

3 新增拦截器 PermissionInterceptor.java
```java
package com.liuweiliang.demo1.aspect;

import com.liuweiliang.demo1.annotation.RequirePermission;
import com.liuweiliang.demo1.common.Result;
import com.liuweiliang.demo1.enums.PermissionEnum;
import com.liuweiliang.demo1.util.JwtUtil;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.util.Map;

@Aspect // 声明切面  类
@Component // 交给Spring管理
public class PermissionAspect {

    @Resource// 注入JwtUtil
    private JwtUtil jwtUtil;

    // 拦截所有贴了@RequirePermission的方法
    @Around("@annotation(requirePermission)")// 它通过 @Aspect 注解标记为切面类，配合 @Around("@annotation(requirePermission)") 环绕通知，精准拦截所有标注了 @RequirePermission 的接口（比如超级管理员才能访问的删除 API）。
    public Object checkPermission(ProceedingJoinPoint joinPoint, RequirePermission requirePermission) throws Throwable {
        // 1. 从注解里获取枚举值（用户要求的权限）

        PermissionEnum requiredPerm = requirePermission.value();
        System.out.println("需要的权限：" + requiredPerm.getPermDesc() + "（码：" + requiredPerm.getPermCode() + "）");

        // 2. 获取当前登录用户的权限（模拟：从token解析，实际业务从数据库/缓存取）
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();

        String token = request.getHeader("Authorization");

        Map<String, Object> authInfo = jwtUtil.parseToken(token.substring(7).trim());

        PermissionEnum userPerm = getPermByCode((int) authInfo.get("permCode"));

        // 3. 权限校验：判断当前用户是否有要求的权限
        if (!requiredPerm.equals(userPerm)) {
            return Result.fail(403, "无权限：需要" + requiredPerm.getPermDesc() + "权限");
        }

        // 4. 权限通过，执行原方法
        return joinPoint.proceed();
    }

    // 辅助方法：根据权限码获取枚举（模拟）
    private PermissionEnum getPermByCode(int code) {
        for (PermissionEnum perm : PermissionEnum.values()) {
            if (perm.getPermCode() == code) {
                return perm;
            }
        }
        return PermissionEnum.ADMIN;
    }
}
```

4 在控制器方法上使用注解
```java
    @GetMapping("auth/delete")
    @RequirePermission(PermissionEnum.SUPER_ADMIN) // 仅超级管理员可调用
    public Result<Boolean> delete(@RequestParam String id)
    {
        adminService.removeById(id);
        return Result.success(true);
    }
```
5 复盘
```
1本次实现的核心逻辑：自定义注解标记 → AOP 切面拦截 → 权限对比校验 → 执行 / 拒绝原方法，实现了权限校验与业务逻辑的解耦。
2关键注解：@Aspect（标记切面）、@Around（环绕通知）、@Retention(RetentionPolicy.RUNTIME)（注解运行时保留），这三个注解是实现自定义权限控制的核心。
3小白避坑点：Lombok 依赖、注解保留策略、JWT 格式、类名与文件名一致，这些细节容易导致程序报错，需要重点注意。
4后续优化方向：补充 JWT 令牌为空、过期、无效的异常处理；支持权限层级（如超级管理员包含普通管理员权限）；引入缓存提升权限校验效率
```



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### jwt 实现
```java
package com.liuweiliang.demo1.interceptor;

import com.liuweiliang.demo1.common.Result;
import com.liuweiliang.demo1.util.JwtUtil;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.PrintWriter;

/**
 * JWT拦截器：校验请求头中的Token合法性
 */
@Component
public class JwtInterceptor implements HandlerInterceptor {

    @Autowired
    private JwtUtil jwtUtil;

    /**
     * 请求处理前执行（核心：校验Token）
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 提取请求头中的Token（前端通常将Token放在Authorization头中，格式：Bearer {Token}）
        String authorization = request.getHeader("Authorization");
        String token = null;
        if (authorization != null) {
            if (authorization.startsWith("Bearer ")){
                token = authorization.substring(7);// 截取Token（去掉"Bearer "前缀）
            }else{
                token = authorization.trim();
            }
        }

        System.out.println("Token：" + token);

        // 2. 校验Token合法性
        if (token == null || !jwtUtil.verifyToken(token)) {
            // 3. Token非法/为空，返回统一的未登录提示（JSON格式）
            response.setContentType("application/json;charset=utf-8");
            PrintWriter writer = response.getWriter();
            // 封装Result对象，转为JSON字符串返回
            Result<Void> result = Result.fail(401, "未登录或Token已失效，请先登录");
            writer.write(new ObjectMapper().writeValueAsString(result));
            writer.flush();
            writer.close();
            return false; // 拦截请求，不放行
        }

        // 4. Token合法，解析Token获取用户信息（可选，存入RequestContextHolder供后续业务使用）
        // Map<String, Object> userInfo = jwtUtil.parseToken(token);
        // RequestContextHolder.getRequestAttributes().setAttribute("userInfo", userInfo, 0);

        // 5. 放行请求，执行接口逻辑
        return true;
    }
}
```

```拦截器（中间件）
package com.liuweiliang.demo1.config;

import com.liuweiliang.demo1.interceptor.JwtInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * Spring MVC 配置类：专门用于注册 JWT 拦截器，配置拦截/排除规则
 * 核心作用：控制哪些接口需要携带有效 JWT 令牌才能访问，哪些接口可以公开访问（无需登录）
 */
@Configuration // 标记该类是 Spring 配置类，Spring 启动时会自动扫描并加载该类的配置（缺一不可）
// 实现 WebMvcConfigurer 接口：获得 Spring MVC 的扩展配置能力，这里主要用于注册拦截器
public class WebMvcConfig implements WebMvcConfigurer {

    /**
     * 注入 JWT 拦截器实例（由 Spring 容器管理）
     * JwtInterceptor 是实际处理 JWT 令牌验证的逻辑类，这里只是完成「注册」，让 Spring MVC 识别它
     */
    @Autowired
    private JwtInterceptor jwtInterceptor;

    /**
     * 重写 WebMvcConfigurer 接口的 addInterceptors 方法：注册自定义拦截器，并配置拦截/排除规则
     * 这是注册拦截器的核心方法，所有自定义 Spring MVC 拦截器都需要在这里注册
     * @param registry 拦截器注册表，用于添加拦截器和配置规则
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 1. 向注册表中添加 JWT 拦截器，让 Spring MVC 识别该拦截器
        registry.addInterceptor(jwtInterceptor)
                // 2. 配置「需要拦截」的接口路径（这些接口必须携带有效 JWT 令牌才能访问，即需要登录后才能调用）
                // 路径规则：/api/v1/auth/** 表示匹配 /api/v1/auth/ 下的所有子路径（如 /api/v1/auth/user/delete、/api/v1/auth/user/query 等）
                .addPathPatterns("/api/v1/auth/**")
                // 3. 配置「需要排除」的接口路径（这些接口不经过拦截器验证，无需登录即可公开访问）
                // 这里排除登录接口：因为登录接口是获取 JWT 令牌的入口，登录前还没有令牌，必须公开访问
                .excludePathPatterns("/api/v1/login");
    }
}

```